var mod = {
    checkForRequiredCreeps: () => {
        //    let requiredCreeps = [];
        let requiredCreeps = [];
        //    for each source{
        var son = 1;
        for (var roomName in Game.rooms) {
            var room = Game.rooms[roomName];
            room.sources.forEach((source) => {
                //        if source has no miner {
                //        requiredCreeps.push(new miner
                let minerHasThisSource = data => { return data.creepType == "miner" && data.destiny == source.id}; // "&& data.ttl > data.spawningTime" I think this is causing doubles for creeps still getting spawned 
                let existingMiner = _.find(Memory.population, minerHasThisSource);
                var existingQueuedMiner = 0;
                let queuedMinerHasThisSource = data => { return data.setup == "miner" && data.destiny == source.id};
                for (var roomName in Game.rooms) {
                    var room = Game.rooms[roomName];
                    if (room.spawnQueueHigh && _.find(room.spawnQueueHigh, queuedMinerHasThisSource)){
                        existingQueuedMiner++;
                    }
                    if (room.spawnQueueLow && _.find(room.spawnQueueLow, queuedMinerHasThisSource)){
                        existingQueuedMiner++;
                    }
                };
                if (!existingMiner && !existingQueuedMiner) {
                    var spawnRoomName = Room.bestSpawnRoomFor(source);
                    var setup = 'miner';
                    var parts = [WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE];
                    for (let iMulti = 0; iMulti < routeRange(spawnRoomName, source.pos.roomName); iMulti++) {
                        parts = parts.concat([MOVE]);
                    }
                    //var cost = Creep.setup.bodyCosts(parts);
                    var name;
                    var destiny = source.id;
                    for (;name == null || Game.creeps[name]; son++) {
                        name = setup + '-' + source.pos.roomName + '-' + son;
                    }
                    Game.rooms[spawnRoomName].spawnQueueHigh.push({
                        parts: parts,
                        name: name,
                        setup: setup,
                        destiny: destiny
                    });
                    console.log(destiny + ": " + source.pos.roomName + " - " + spawnRoomName);
                }
                //      }
            });
            //    }
        }
        //    if room.haulers == 0 
        //      requiredCreeps.push(new miner);
        //    for each creep in requiredCreeps{
        //      let room = Room.bestSpawnRoom(task);
        //      room.queue.push(creep);
        //    }


        /*            let notDeterminated = source => {
                        let hasThisSource = data => { return data.determinatedTarget == source.id };
                        let existingBranding = _.find(Memory.population, hasThisSource);
                        return !existingBranding;
                    };
                    source = _.find(creep.room.sources, notDeterminated);
                    if( source ) {
                        creep.data.determinatedTarget = source.id;
                    }
                    */
        /*
            var isAddable = target => that.isAddableTarget(target, creep);
            return _.find(creep.room.constructionSites, isAddable);
            */
        /*
                        let guests = _.countBy(source.targetOf, 'creepType');
                        let count = guests[creep.data.creepType];
                        */

        /*
        var loop = spawn => {
                        if(spawn.room.my) spawn.loop();
                    }
                    _.forEach(Game.spawns, loop);
                    */
    }
};

module.exports = mod;